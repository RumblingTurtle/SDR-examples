close all; clear; clear classes;
clc; 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dynamics

SRD = SRDuserinterface;
LinkArray = SRD_get('LinkArray');

SymbolicEngine = SRD.DeriveEquationsForSimulation('UseCasadi', true, ...
    'LinkArray',   LinkArray, ...                                 
    'ToLinearize', false, ...                    %needed if you want to use LQR and other linearization-based methods
    'ToRecreateSymbolicEngine', true, ...        %set false if you already have a symbolic engine saved and you want to load it (doesn't work with Casadi)
    'dissipation_coefficients', [], ...           %provide non-default dissipation (viscous friction) coefficients
    'ToSimplify', true, ...                      %if you don't use Casadi, set true, unless your robot is huge
    'ToUseParallelizedSimplification', false, ... %if you don't use Casadi, set true to automatically palallelize your symbolic computations
    'NumberOfWorkers', 8, ...                     %if you don't use Casadi, set how many workers you want to palallelize your symbolic computations
    'ToOptimizeFunctions', true, ...              %if you don't use Casadi, set false to skip function optimization (will result in very slow simulation)
    'ToSaveSymbolicEngine', false);               %if you use Casadi, set false to ovoid errors related to MATLAB trying to serialize Casadi objects


SRD_dynamics_derive_JacobiansForLinkArray('SymbolicEngine', SymbolicEngine);

H = SRD_dynamics_derive_JSIM('SymbolicEngine', SymbolicEngine);

[in, dJSIM] = SRD_dynamics_derive_GeneralizedInertialForces_via_dJSIM(...
    'SymbolicEngine', SymbolicEngine, ...
    'JointSpaceInertiaMatrix', H);

g = SRD_dynamics_derive_GeneralizedGravitationalForces(...
    'SymbolicEngine', SymbolicEngine, ...
    'GravitationalConstant', [0; 0; -9.8]);

d = SRD_dynamics_derive_GeneralizedDissipativeForces_uniform(...
    'SymbolicEngine', SymbolicEngine, ...
    'UniformCoefficient', 1);

%NaiveControlMap
T = SRD_dynamics_derive_ControlMap_eye(...
    'SymbolicEngine', SymbolicEngine);

description = SRD_generate_dynamics_generalized_coordinates_model(...
    'SymbolicEngine', SymbolicEngine, ...
    'Symbolic_ToOptimizeFunctions', true, ...
    'Casadi_cfile_name', 'g_dynamics_generalized_coordinates', ...
    'H', H, ...
    'c', (in + g + d), ...
    'T', T, ...
    'FunctionName_H', 'g_dynamics_H', ...
    'FunctionName_c', 'g_dynamics_c', ...
    'FunctionName_T', 'g_dynamics_T', ...
    'Path', 'Dynamics/');




Handler_dynamics_generalized_coordinates_model = SRD_get_handler__dynamics_generalized_coordinates_model('description', description);
SRD_save(Handler_dynamics_generalized_coordinates_model, 'Handler_dynamics_generalized_coordinates_model');


Handler_dynamics_generalized_coordinates_model = SRD_get('Handler_dynamics_generalized_coordinates_model');
InitialPosition = SRD_get('InitialPosition');
H = Handler_dynamics_generalized_coordinates_model.get_joint_space_inertia_matrix(InitialPosition)


H1 = Handler_dynamics_generalized_coordinates_model.get_joint_space_inertia_matrix(InitialPosition + 0.1*randn(size(InitialPosition)))



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Linearization
% 
% description = SRD_generate_dynamics_linearization(...
%     'SymbolicEngine',                         SymbolicEngine, ...
%     'Symbolic_ToOptimizeFunctions',           true, ...
%     'Casadi_cfile_name',                      'g_dynamics_linearization', ...
%     'FunctionName_A',                         'g_linearization_A', ...
%     'FunctionName_B',                         'g_linearization_B', ...
%     'FunctionName_c',                         'g_linearization_c', ...
%     'Path',                                   'Linearization/');
% 
% Handler_dynamics_Linearized_Model = SRD_get_handler__dynamics_linearized_model('description', description);
% SRD_save(Handler_dynamics_Linearized_Model, 'Handler_dynamics_Linearized_Model');

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Constraints
% 
% %%%%%%%%%%%%
% %construct constraint
% constraint = SymbolicEngine.GeometryArray{3}.Link.AbsoluteFollower(1);
% %%%%%%%%%
% 
% description = SRD_generate_second_derivative_Jacobians('SymbolicEngine', SymbolicEngine, ...
%     'Task',                                   constraint, ...
%     'Casadi_cfile_name',                     'g_Constraints', ...
%     'Symbolic_ToSimplify',                    true, ...
%     'Symbolic_UseParallelizedSimplification', false, ...
%     'Symbolic_ToOptimizeFunctions',           true, ...
%     'FunctionName_Task',                     'g_Constraint', ...
%     'FunctionName_TaskJacobian',             'g_Constraint_Jacobian', ...
%     'FunctionName_TaskJacobian_derivative',  'g_Constraint_Jacobian_derivative', ...
%     'Path',                                  'Constraints/');
% 
% 
% Handler_Constraints_Model = SRD_get_handler__Constraints_model('description', description, ...
%     'dof_robot', SymbolicEngine.dof, ...
%     'dof_Constraint', length(constraint));
% SRD_save(Handler_Constraints_Model, 'Handler_Constraints_Model');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inverse kinematics

%%%%%%%%%%%%
%construct inverse kinematics task
% rC = SymbolicEngine.GetCoM;
% iiwa_link_7 = SRD_LinkGet(SymbolicEngine.LinkArray, 'iiwa_link_7');
% 
% r_EE = iiwa_link_7.AbsoluteCoM; %(!) it has two followers, dunno which to pick, or what they mean, needs to be fixed
% 
% Task = [rC; r_EE; SymbolicEngine.q(end)]; 
Task = [SymbolicEngine.q]; 
%%%%%%%%%

description = SRD_generate_second_derivative_Jacobians('SymbolicEngine', SymbolicEngine, ...
    'Task',                                      Task, ...
    'Casadi_cfile_name',                         'g_InverseKinematics', ...
    'Symbolic_ToSimplify',                       true, ...
    'Symbolic_UseParallelizedSimplification',    false, ...
    'Symbolic_ToOptimizeFunctions',              true, ...
    'FunctionName_Task',                         'g_InverseKinematics_Task', ...
    'FunctionName_TaskJacobian',                 'g_InverseKinematics_TaskJacobian', ...
    'FunctionName_TaskJacobian_derivative',      'g_InverseKinematics_TaskJacobian_derivative', ...
    'Path',                                      'InverseKinematics/');

Handler_IK_Model = SRD_get_handler__IK_model('description', description, ...
    'dof_robot', SymbolicEngine.dof, ...
    'dof_Task', length(Task));
SRD_save(Handler_IK_Model, 'Handler_IK_Model');



